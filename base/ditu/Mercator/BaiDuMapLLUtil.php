<?php
/*
    坐标系说明
    WGS84：为一种大地坐标系，也是目前广泛使用的GPS全球卫星定位系统使用的坐标系。

    GCJ02：是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。

    BD09：为百度坐标系，在GCJ02坐标系基础上再次加密。其中bd09ll表示百度经纬度坐标，bd09mc表示百度墨卡托米制坐标

    坐标转换服务默认输入输出坐标类型为百度坐标（BD09），同时可通过参数（"from","to"）控制输入输出坐标类型。输入坐标支持以上三种坐标系，输出坐标支持-国测局坐标（GCJ02）和百度坐标（BD09）

    注意：不同类型坐标如需转换，请使用百度地图开放平台提供的标准坐标转换接口。请勿使用其他渠道提供的坐标转换方法，以免影响坐标转换精度。

    原理：百度经纬度左边转换为专门用于程序计算的墨卡托坐标，然后利用勾股定理计算直线距离

 */

//目前只支持从经纬度转墨卡托
class BaiDuMapLLUtil
{
    const GCJ02LL = 1;      //国测局（GCJ02）坐标;
    const BD09LL = 2;       //百度经纬度坐标
    const WGS84LL = 3;      //WGS84坐标,GPS
    const GCJ02MC = 4;
    const bBD09MC = 5;       //百度米制经纬度坐标(墨卡托坐标)
    const WGS84MC = 6;

    public static $LLBAND = [75, 60, 45, 30, 15, 0];
    public static $MCBAND = [12890594.86, 8362377.87, 5591021, 3481989.83,1678043.12, 0];

    public static $MC2LL = [
        [1.410526172116255e-008, 8.983055096488720e-006, -1.99398338163310, 2.009824383106796e+002, -1.872403703815547e+002, 91.60875166698430, -23.38765649603339, 2.57121317296198,-0.03801003308653, 1.733798120000000e+007],
        [-7.435856389565537e-009, 8.983055097726239e-006, -0.78625201886289, 96.32687599759846,-1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1.026014486000000e+007],
        [-3.030883460898826e-008, 8.983055099835780e-006, 0.30071316287616, 59.74293618442277, 7.35798407487100, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6.856817370000000e+006],
        [-1.981981304930552e-008, 8.983055099779535e-006, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4.482777060000000e+006],
        [3.091913710684370e-009, 8.983055096812155e-006, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.63218178102420, -0.00663494467273, 0.03430082397953, -0.00466043876332,2.555164400000000e+006],
        [2.890871144776878e-009, 8.983055095805407e-006, -0.00000003068298, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 8.260885000000000e+005],
    ];

    public static  $LL2MC = [
        [-0.00157021024440, 1.113207020616939e+005, 1.704480524535203e+015, -1.033898737604234e+016, 2.611266785660388e+016, -3.514966917665370e+016, 2.659570071840392e+016, -1.072501245418824e+016, 1.800819912950474e+015, 82.50000000000000],
        [8.277824516172526e-004, 1.113207020463578e+005, 6.477955746671608e+008, -4.082003173641316e+009, 1.077490566351142e+010, -1.517187553151559e+010, 1.205306533862167e+010, -5.124939663577472e+009, 9.133119359512032e+008, 67.50000000000000],
        [0.00337398766765, 1.113207020202162e+005, 4.481351045890365e+006, -2.339375119931662e+007, 7.968221547186455e+007, -1.159649932797253e+008, 9.723671115602145e+007, -4.366194633752821e+007, 8.477230501135234e+006, 52.50000000000000],
        [0.00220636496208, 1.113207020209128e+005, 5.175186112841131e+004, 3.796837749470245e+006, 9.920137397791013e+005, -1.221952217112870e+006, 1.340652697009075e+006, -6.209436990984312e+005, 1.444169293806241e+005, 37.50000000000000],
        [-3.441963504368392e-004, 1.113207020576856e+005, 2.782353980772752e+002, 2.485758690035394e+006, 6.070750963243378e+003, 5.482118345352118e+004, 9.540606633304236e+003, -2.710553267466450e+003, 1.405483844121726e+003, 22.50000000000000],
        [-3.218135878613132e-004, 1.113207020701615e+005, 0.00369383431289,8.237256402795718e+005, 0.46104986909093, 2.351343141331292e+003, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45000000000000],
    ];

    private static function _convert($x, $y, $factor)
    {
        $toX = $factor[0] + $factor[1] * abs($x);
        $temp = abs($y)/$factor[9];

        $toY = $factor[2]
            +$factor[3]*$temp
            +$factor[4]*$temp*$temp
            +$factor[5]*$temp*$temp*$temp
            +$factor[6]*$temp*$temp*$temp*$temp
            +$factor[7]*$temp*$temp*$temp*$temp*$temp
            +$factor[8]*$temp*$temp*$temp*$temp*$temp*$temp;

        $toX *= ($x < 0? -1: 1);
        $toY *= ($y < 0? -1: 1);

        return [$toX, $toY];
    }

    //经纬度转墨卡托坐标
    public static function llToMc($x, $y)
    {
        if ($x > 180.0) {
            $x = 180.0;
        } else if ($x < -180.0) {
            $x = -180.0;
        }

        if ($y < 1.0E-7 && $y >= 0.0) {
            $y = 1.0E-7;
        } else if ($y < 0 && $y > -1.0E-7) {
            $y = -1.0E-7;
        } else if ($y > 74) {
            $y = 74;
        } else if ($y < -74) {
            $y = -74;
        }

        $factor = [];
        $size = count(self::$LLBAND);
        for ($i = 0; $i < $size; $i++) {
            if (abs($y) > self::$LLBAND[$i]) {
                $factor = self::$LL2MC[$i];
                break;
            }
        }

        return self::_convert($x, $y, $factor);
    }

    //墨卡托坐标转经纬度
    public static function mcToLl($x, $y)
    {
        if ($x > 20037508.342) {
            $x = 20037508.342;
        } else if ($x < -20037508.342) {
            $x = -20037508.342;
        }

        if ($y < 1.0E-6 && $y >= 0) {
            $y = -1.0E-6;
        } else if ($y < 0 && $y > -1.0E-6) {
            $y = -1.0E-6;
        } else if ($y > 20037508.342) {
            $y =  20037508.342;
        } else if ($y < -20037508.342) {
            $y = -20037508.342;
        }

        $factor = [];
        $size = count(self::$MCBAND);
        for ($i = 0; $i < $size; $i++) {
            if (abs($y) > self::$MCBAND[$i]) {
                $factor = self::$MC2LL[$i];
                break;
            }
        }

        return self::_convert($x, $y, $factor);
    }

    public static function getMercatorByLocation($longitude, $latitude)
    {
//        $PI = 3.14159265358979323846;
//        $newX = $longitude * 20037508.342789 / 180;
//        $newY = (log(tan((90 + $latitude) * $PI / 360)) / ($PI / 180));
//        $newY = $newY * 20037508.342789 / 180;
//        return [$newX, $newY];

        return self::llToMc($longitude, $latitude);
    }

    //勾股定理计算
    public static function getDistance($startLongitude, $startLatitude, $endLongitude, $endLatitude)
    {
        list($startXMercator,$startYMercator) = self::getMercatorByLocation($startLongitude,$startLatitude);
        list($endXMercator,$endYMercator) = self::getMercatorByLocation($endLongitude,$endLatitude);

        return self::calculateTriangleBorder($startXMercator,$startYMercator,$endXMercator,$endYMercator);
    }

    public static function calculateTriangleBorder($startXMercator,$startYMercator,$endXMercator,$endYMercator)
    {
        $a = pow(($startXMercator - $endXMercator), 2);
        $b = pow(($startYMercator - $endYMercator), 2);
        $result = sqrt($a + $b);
        return number_format($result, 2, '.', '');
    }
}